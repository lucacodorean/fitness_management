-- SQL Queries

1. Selecteaz? toate abonamentele cu pre?ul mai mare de 50:
   SELECT * FROM subscriptions WHERE price > 50;

2. Afi?eaz? numele, prenumele ?i email-ul clien?ilor cu abonamente active:
   SELECT firstname, lastname, email FROM clients WHERE has_active_sub = true;

3. Arat? detaliile pl??ilor f?cute Œn ultimele 7 zile:
   SELECT * FROM payments WHERE payed_at >= NOW() - INTERVAL 7 DAY;

4. Listeaz? toate rolurile al?turi de numele permisiunilor asociate:
   SELECT roles.title, permissions.action
   FROM roles
   JOIN permissions_for_roles ON roles.id = permissions_for_roles.role_id
   JOIN permissions ON permissions_for_roles.permission_id = permissions.id;

5. Afi?eaz? to?i angaja?ii cu un salariu mai mare de 5000:
   SELECT * FROM employee WHERE wage > 5000;

6. G?se?te evenimentele jurnalelor care con?in cuvƒntul cheie "re?ea":
   SELECT * FROM jurnal_events WHERE descr LIKE '%re?ea%';

7. Arat? num?rul total de clien?i:
   SELECT COUNT(*) as total_clients FROM clients;

8. Afi?eaz? detaliile abonamentului ?i data pl??ii pentru un anumit client:
   SELECT s.*, p.payed_at
   FROM subscriptions s
   JOIN payments p ON s.id = p.subscription_id
   WHERE p.client_id = <id_client>;

9. G?se?te cel mai recent eveniment jurnal pentru fiecare client:
   SELECT c.id as client_id, c.firstname, c.lastname, je.descr as recent_event
   FROM clients c
   LEFT JOIN jurnal j ON c.id = j.client_id
   LEFT JOIN jurnal_events je ON j.event_id = je.id
   ORDER BY j.created_at DESC
   LIMIT 1;

10. Calculeaz? salariul mediu al angaja?ilor:
    SELECT AVG(wage) as average_salary FROM employee;

11. Afi?eaz? abonamentele care nu au fost Œnc? pl?tite:
    SELECT s.*
    FROM subscriptions s
    LEFT JOIN payments p ON s.id = p.subscription_id
    WHERE p.id IS NULL;

12. Listeaz? clien?ii ?i detaliile abonamentului pentru cei cu abonamente active ?i pre? mai mic de 100:
    SELECT c.*, s.*
    FROM clients c
    JOIN subscriptions s ON c.subscription_id = s.id
    WHERE c.has_active_sub = true AND s.price < 100;

13. Afi?eaz? toate pl??ile ?i data viitoarei pl??i pentru clien?ii cu abonamente active:
    SELECT c.id, c.firstname, c.lastname, p.payed_at, c.next_payment_at
    FROM clients c
    JOIN payments p ON c.id = p.client_id
    WHERE c.has_active_sub = true;

14. G?se?te cele mai scumpe abonamente disponibile:
    SELECT * FROM subscriptions ORDER BY price DESC LIMIT 1;

15. Afi?eaz? toate evenimentele jurnalelor pentru un anumit client Œn ordine cronologic? invers?:
    SELECT je.descr, j.created_at
    FROM jurnal j
    JOIN jurnal_events je ON j.event_id = je.id
    WHERE j.client_id = <id_client>
    ORDER BY j.created_at DESC;

16. Calculeaz? num?rul total de angaja?i ?i num?rul de angaja?i pentru fiecare rol:
    SELECT r.title, COUNT(e.id) as num_employees
    FROM roles r
    LEFT JOIN employee e ON r.id = e.role_id
    GROUP BY r.title;

17. Afi?eaz? detaliile angaja?ilor ?i rolelor lor, sortate dup? rating descresc?tor:
    SELECT e.*, r.title
    FROM employee e
    JOIN roles r ON e.role_id = r.id
    ORDER BY e.rating DESC;

18. G?se?te clien?ii care au pl?tit cel mai mult Œntr-o singur? tran??:
    SELECT c.*, MAX(p.price) as max_payment
    FROM clients c
    JOIN payments p ON c.id = p.client_id
    GROUP BY c.id
    ORDER BY max_payment DESC;

19. Afi?eaz? clien?ii cu abonamente active ?i data urm?toarei pl??i este Œn viitor:
    SELECT * FROM clients WHERE has_active_sub = true AND next_payment_at > NOW();

20. G?se?te clien?ii care nu au pl?tit niciodat? pentru abonamentul lor:
    SELECT c.*
    FROM clients c
    LEFT JOIN payments p ON c.id = p.client_id AND c.subscription_id = p.subscription_id
    WHERE p.id IS NULL;

21. Calculeaz? suma total? a pl??ilor pentru fiecare abonament:
    SELECT s.id, s.description, SUM(p.price) as total_payments
    FROM subscriptions s
    LEFT JOIN payments p ON s.id = p.subscription_id
    GROUP BY s.id;

22. Afi?eaz? clien?ii care nu au fost niciodat? Œnregistra?i Œn jurnal:
    SELECT c.*
    FROM clients c
    LEFT JOIN jurnal j ON c.id = j.client_id
    WHERE j.id IS NULL;

23. Calculeaz? salariul total pl?tit angaja?ilor pentru fiecare rol:
    SELECT r.title, SUM(e.wage) as total_wages
    FROM roles r
    JOIN employee e ON r.id = e.role_id
    GROUP BY r.title;

24. Afi?eaz? angaja?ii cu cele mai mari salarii pentru fiecare rol:
    SELECT e.*
    FROM employee e
    JOIN (
        SELECT role_id, MAX(wage) as max_wage
        FROM employee
        GROUP BY role_id
    ) max_wages ON e.role_id = max_wages.role_id AND e.wage = max_wages.max_wage;

25. G?se?te clien?ii care au evenimente jurnale Œnainte de data specificat?:
    SELECT DISTINCT c.*
    FROM clients c
    JOIN jurnal j ON c.id = j.client_id
    WHERE j.created_at < '2023-01-01';

26. Afi?eaz? rolurile care nu au nicio permisiune asociat?:
    SELECT r.*
    FROM roles r
    LEFT JOIN permissions_for_roles pr ON r.id = pr.role_id
    WHERE pr.id IS NULL;

27. Calculeaz? num?rul total de evenimente jurnale pentru fiecare client:
    SELECT c.id, c.firstname, c.lastname, COUNT(j.id) as num_journal_events
    FROM clients c
    LEFT JOIN jurnal j ON c.id = j.client_id
    GROUP BY c.id;

28. Afi?eaz? angaja?ii care au fost angaja?i Œnainte de o anumit? dat?:
    SELECT * FROM employee WHERE employed_at < '2022-01-01';

29. G?se?te clien?ii care au pl?tit cel pu?in o dat? ?i nu au abonamente active:
    SELECT c.*
    FROM clients c
    JOIN payments p ON c.id = p.client_id
    WHERE c.has_active_sub = false;

30. Calculeaz? durata medie a angaj?rii pentru fiecare rol:
    SELECT r.title, AVG(DATEDIFF(NOW(), e.employed_at)) as avg_employment_duration
    FROM roles r
    JOIN employee e ON r.id = e.role_id
    GROUP BY r.title;
